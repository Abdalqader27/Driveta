import 'dart:convert';import 'package:get/get.dart';import 'package:get/get_core/src/get_main.dart';import 'package:google_maps_flutter/google_maps_flutter.dart';import 'package:rider/common/utils/signal_r_new.dart';import 'package:rider/main.dart';import '../../blocs/map_bloc.dart';import '../../features/data/models/driver.dart';import '../../features/data/models/marker_config.dart';import '../../features/injection/injection_network.dart';import '../../features/presentation/pages/map/map_trip_live/map_trip_live.dart';import '../../generated/assets.dart';String acceptedDriverID = '';Driver acceptedDriver = Driver();// Configer the loggingconst hubUrl = '$kBase' 'deliveryHub/';class SignalRRider {  static final SignalRRider _instance = SignalRRider._();  static const String connectionIsOpenPropName = "connectionIsOpen";  SignalRRider._();  factory SignalRRider() => _instance;  /// For open and close signal R  Future<bool> openConnection() async {    final hub = si<SignalRService>();    try {      await hub.openHub(hubUrl);      print("hub ${hub.isConnected(hubUrl)}");      hub.on(          hubUrl: hubUrl,          methodName: "ReceiveLocations",          method: onReceiveLocations);      hub.on(          hubUrl: hubUrl,          methodName: "ReceiveAcceptation",          method: onReceiveAcceptation);      hub.on(          hubUrl: hubUrl,          methodName: "ReceiveArrivedToLocation",          method: onReceiveArrivedToLocation);      hub.on(          hubUrl: hubUrl,          methodName: "ReceiveStarting",          method: onReceiveStarting);      hub.on(          hubUrl: hubUrl,          methodName: "ReceiveEndingCustomer",          method: onReceiveEndingCustomer);      hub.onClose(hubUrl, (e) => print("Connection Closed : $e"));      hub.onReconnecting(hubUrl, (e) => print("onÙReconnecting $e"));      hub.onReconnected(hubUrl, (id) => print("onReconnected $id"));      return true;    } catch (e) {      print("openHub error : $e");      return false;    }  }  Future<void> stopConnection() async {    print("stopConnection is fired ");    final hub = si<SignalRService>();    if (hub.isConnected('$kBase' 'deliveryHub/')) {      await hub.closeHub('$kBase' 'deliveryHub/');    }  }  //  ///1. AddDelivery (invoke) (Customer)  Future<void> addDelivery({    required String startLat,    required String startLong,    required String endLat,    required String endLong,    required int distance,    required String expectedTime,    required int price,    required String pickUp,    required String dropOff,  }) async {    print("AddDelivery is fired ");    try {      si<SignalRService>().invoke(        hubUrl: hubUrl,        methodName: "AddDelivery",        args: <Object>[          {            'startLat': startLat.toString(),            'startLong': startLong.toString(),            'endLat': endLat.toString(),            'endLong': endLong.toString(),            'distance': distance,            'price': price,            'expectedTime': expectedTime,            'pickUp': pickUp.toString(),            'dropOff': dropOff.toString(),          }        ],      );      print("AddDelivery is sending data ${json.encode({            'startLat': startLat.toString(),            'startLong': startLong.toString(),            'endLat': endLat.toString(),            'endLong': endLong.toString(),            'distance': distance,            'price': price,            'expectedTime': expectedTime,            'pickUp': pickUp.toString(),            'dropOff': dropOff.toString(),          })} ");    } catch (e) {      print("AddDelivery is catching error $e ");      if (e          .toString()          .contains('Cannot send data if the connection is not in the')) {}    }  }  Future<void> endDeliveryCustomer(      {required num price,      required String id,      required String endLat,      required String endLong,      required num distance,      required String dropOff,      required String expectedTime}) async {    print("EndDeliveryCustomer is fired ");    try {      si<SignalRService>().invoke(        hubUrl: hubUrl,        methodName: "EndDeliveryCustomer",        args: <Object>[          {            'price': price,            'id': id,            'endLat': endLat,            'endLong': endLong,            'distance': distance,            'expectedTime': expectedTime,            'dropOff': dropOff          }        ],      );      print("EndDeliveryCustomer is sending data ${json.encode({            'price': price,            'id': id,            'endLat': endLat,            'endLong': endLong,            'distance': distance,            'expectedTime': expectedTime,            'dropOff': dropOff          })} ");    } catch (e) {      print("EndDeliveryCustomer is catching error $e ");    }  }//ReceiveAcceptation(Guid id) (on) (Customer) (driverId)// Notify by driver (Tell him that he had been accepted by driver blabla)  static void onReceiveAcceptation(List<Object>? arguments) {    print("ReceiveAcceptation $arguments");    if (arguments != null) {      if (acceptedDriverID.isEmpty) {        acceptedDriverID = arguments[0].toString();        Get.to(() => const MapTripLive());      }    }  }//ReceiveLocations list drivers  void onReceiveLocations(List<Object>? arguments) {    if (arguments != null) {      print("ReceiveLocations ${json.encode(arguments[0])}");      for (var item in arguments[0] as List) {        final driver = Driver.fromJson(item);        if (acceptedDriverID.isEmpty) {          if (driver.lat != null && driver.long != null) {            si<MapBloc>().setMarker(MarkerConfig(              point:                  LatLng(double.parse(driver.lat!), double.parse(driver.long!)),              pinPath: Assets.pinsDrivingPin,              markerId: MarkerId(driver.id.toString()),              snippet: '${driver.name}',              title: '${driver.isAvailable}',            ));          }        } else {          if (driver.id.toString() == acceptedDriverID) {            acceptedDriver = driver;            si<MapBloc>().setMarker(MarkerConfig(              point:                  LatLng(double.parse(driver.lat!), double.parse(driver.long!)),              pinPath: Assets.pinsDrivingPin,              markerId: MarkerId(driver.id.toString()),              snippet: '${driver.name}',              title: '${driver.isAvailable}',            ));          }        }      }    }  }  static void onReceiveStarting(List<Object>? arguments) {    print("ReceiveStarting ${arguments}");  }//Notify by driver (Tell him that he has reach the start location)// Here you should putting some text telling the customer that driver has arrived  static void onReceiveArrivedToLocation(List<Object>? arguments) {    print("ReceiveArrivedToLocation ${arguments}");  }  //Here the customer has to pay to the driver and you should showing him a model of rating the driver  // Rating the driver request:  // [HttpPut]  // CustomerApp/RateDelivery(Guid id, double rate)  // Response: bool  // the id is deliveryId  static void onReceiveEndingCustomer(List<Object>? arguments) {    print("ReceiveEndingCustomer ${arguments}");  }}