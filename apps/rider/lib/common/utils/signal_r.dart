import 'package:core/core.dart';import 'package:get/get.dart';import 'package:get/get_core/src/get_main.dart';import 'package:google_maps_flutter/google_maps_flutter.dart';import 'package:rider/main.dart';import 'package:signalr_netcore/http_connection_options.dart';import 'package:signalr_netcore/hub_connection.dart';import 'package:signalr_netcore/hub_connection_builder.dart';import '../../blocs/map_bloc.dart';import '../../features/data/models/driver.dart';import '../../features/data/models/marker_config.dart';import '../../features/injection/injection_network.dart';import '../../features/presentation/pages/map/map_trip_live/map_trip_live.dart';import '../../generated/assets.dart';String acceptedDriverID = '';Driver acceptedDriver = Driver();class SignalRRider {  static final SignalRRider _instance = SignalRRider._();  static late HubConnection? _hubConnection;  static bool _connectionIsOpen = false;  static const String connectionIsOpenPropName = "connectionIsOpen";  static bool get connectionIsOpen => _connectionIsOpen;  SignalRRider._() {    _hubConnection = HubConnectionBuilder().withUrl('$kBase' 'deliveryHub/',        options: HttpConnectionOptions(      accessTokenFactory: () async {        return si<SStorage>().get(key: kAccessToken, type: ValueType.string);      },    )).build();    _hubConnection!.on("ReceiveAcceptation", onReceiveAcceptation);    _hubConnection!.on("ReceiveLocations", onReceiveLocations);    _hubConnection!.on("ReceiveStarting", onReceiveStarting);    _hubConnection!.on("ReceiveEndingCustomer", onReceiveEndingCustomer);  }  factory SignalRRider() => _instance;  /// For open and close signal R  Future<bool> openConnection() async {    try {      if (_hubConnection!.state != HubConnectionState.Connected) {        await _hubConnection!.start();        _connectionIsOpen = true;        print("SignalR is $_connectionIsOpen");      } else {        print("SignalR is Connected");      }      return true;    } catch (e) {      print("Signal$e");      return false;    }  }  Future<void> stopConnection() async {    if (_hubConnection!.state == HubConnectionState.Connected) {      await _hubConnection!.stop();      _hubConnection = null;      _connectionIsOpen = false;      print("SignalR is has$_connectionIsOpen");    }  }  Future<void> sendLocation({LatLng? point}) async {    try {      if (connectionIsOpen == false ||          _hubConnection!.state != HubConnectionState.Connected) {        await openConnection();      }      if (point != null) {        try {          _hubConnection!.invoke(            "SendLocation",            args: <Object>[              point.longitude.toString(),              point.longitude.toString()            ],          );        } catch (_) {}      }    } catch (_) {}  }  ///1. AddDelivery (invoke) (Customer)  Future<void> addDelivery({    required String startLat,    required String startLong,    required String endLat,    required String endLong,    required int distance,    required String expectedTime,    required int price,    required String pickUp,    required String dropOff,  }) async {    if (connectionIsOpen == false ||        _hubConnection!.state != HubConnectionState.Connected) {      await openConnection();    }    try {      _hubConnection!.invoke(        "AddDelivery",        args: <Object>[          {            'startLat': startLat.toString(),            'startLong': startLong.toString(),            'endLat': endLat.toString(),            'endLong': endLong.toString(),            'distance': distance,            'price': price,            'expectedTime': expectedTime,            'pickUp': pickUp.toString(),            'dropOff': dropOff.toString(),          }        ],      );    } catch (e) {}  }  Future<void> endDeliveryCustomer(      {required num price,      required String id,      required String endLat,      required String endLong,      required num distance,      required String dropOff,      required String expectedTime}) async {    try {      if (connectionIsOpen == false ||          _hubConnection!.state != HubConnectionState.Connected) {        await openConnection();      }      _hubConnection!.invoke(        "EndDeliveryCustomer",        args: <Object>[          {            'price': price,            'id': id,            'endLat': endLat,            'endLong': endLong,            'distance': distance,            'expectedTime': expectedTime,            'dropOff': dropOff          }        ],      );    } catch (_) {}  }//ReceiveAcceptation(Guid id) (on) (Customer) (driverId)// Notify by driver (Tell him that he had been accepted by driver blabla)  static void onReceiveAcceptation(List<Object>? arguments) {    print("ReceiveAcceptation $arguments");    if (arguments != null) {      if (acceptedDriverID.isEmpty) {        acceptedDriverID = arguments[0].toString();        Get.to(() => const MapTripLive());      }    }  }//ReceiveLocations list drivers  static void onReceiveLocations(List<Object>? arguments) {    if (arguments != null) {      print("onReceiveLocations ${arguments[0]}");      for (var item in arguments[0] as List) {        final driver = Driver.fromJson(item);        if (acceptedDriverID.isEmpty) {          si<MapBloc>().setMarker(MarkerConfig(            point:                LatLng(double.parse(driver.lat!), double.parse(driver.long!)),            pinPath: Assets.pinsDrivingPin,            markerId: MarkerId(driver.id.toString()),            snippet: '${driver.name}',            title: '${driver.isAvailable}',          ));        } else {          if (driver.id.toString() == acceptedDriverID) {            acceptedDriver = driver;            si<MapBloc>().setMarker(MarkerConfig(              point:                  LatLng(double.parse(driver.lat!), double.parse(driver.long!)),              pinPath: Assets.pinsDrivingPin,              markerId: MarkerId(driver.id.toString()),              snippet: '${driver.name}',              title: '${driver.isAvailable}',            ));          }        }      }    }  }//Notify by driver (Tell him that he has reach the start location)// Here you should putting some text telling the customer that driver has arrived  static void onReceiveStarting(List<Object>? arguments) {    print("onReceiveStarting ${arguments}");  }  //Here the customer has to pay to the driver and you should showing him a model of rating the driver  // Rating the driver request:  // [HttpPut]  // CustomerApp/RateDelivery(Guid id, double rate)  // Response: bool  // the id is deliveryId  static void onReceiveEndingCustomer(List<Object>? arguments) {    print("ReceiveEndingCustomer ${arguments}");  }}